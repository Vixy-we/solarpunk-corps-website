<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solarpunk Corps - Living</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Exo+2:wght@900&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background: #080c08; 
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            filter: drop-shadow(0 0 15px rgba(57, 255, 20, 0.2)); 
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="logoCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('logoCanvas');
        const ctx = canvas.getContext('2d');

        // --- CONFIGURATION ---
        const config = {
            lines: ["SOLARPUNK", "CORPS"],
            colors: {
                textFill: '#1a1a1a',
                roadLine: '#e0e0e0',
                goldOutline: '#c5a028',
                bronzeShadow: '#5c4015',
                vineStem: '#32cd32',
                vineHighlight: '#98fb98',
                leafFill: '#39ff14',
                leafDark: '#006400'
            },
            leafSizeBase: 7.5,   // 3/4 of previous size (was 10)
            leafDensity: 0.35,  
            animTime: 0
        };

        function randomRange(min, max) { return Math.random() * (max - min) + min; }

        class Leaf {
            constructor(x, y, angle, size) {
                this.x = x;
                this.y = y;
                this.baseAngle = angle;
                this.size = size;
                this.swaySpeed = 1 + Math.random();
                this.swayOffset = Math.random() * 10;
            }

            draw(ctx, time, parentSwayX, parentSwayY) {
                // Leaf swaying rotation
                const rotSway = Math.sin(time * this.swaySpeed + this.swayOffset) * 0.3;
                const currentAngle = this.baseAngle + rotSway;

                // Move with parent vine + local wind
                const drawX = this.x + parentSwayX;
                const drawY = this.y + parentSwayY;

                ctx.save();
                ctx.translate(drawX, drawY);
                ctx.rotate(currentAngle);

                ctx.beginPath();
                // Tear-drop shape
                ctx.moveTo(0, 0);
                ctx.bezierCurveTo(this.size, -this.size/2.5, this.size*1.8, -this.size/4, this.size*2.2, 0);
                ctx.bezierCurveTo(this.size*1.8, this.size/4, this.size, this.size/2.5, 0, 0);
                
                const grad = ctx.createLinearGradient(0, 0, this.size*2, 0);
                grad.addColorStop(0, config.colors.leafDark);
                grad.addColorStop(0.4, '#228b22');
                grad.addColorStop(1, config.colors.leafFill);
                ctx.fillStyle = grad;
                ctx.fill();

                ctx.restore();
            }
        }

        class VineSegment {
            constructor(startX, startY, endX, endY, cp1x, cp1y, cp2x, cp2y, isFront) {
                this.start = {x: startX, y: startY};
                this.end = {x: endX, y: endY};
                this.cp1 = {x: cp1x, y: cp1y};
                this.cp2 = {x: cp2x, y: cp2y};
                this.isFront = isFront;
                this.leaves = [];
                
                // Random offset for this vine's movement
                this.animOffset = Math.random() * 10;
                
                this.initLeaves();
            }

            initLeaves() {
                const dx = this.end.x - this.start.x;
                const dy = this.end.y - this.start.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const steps = Math.floor(dist / 12); 

                for(let i=1; i<steps; i++) {
                    if (Math.random() > (1 - config.leafDensity)) {
                        const t = i/steps;
                        
                        const cx = Math.pow(1-t,3)*this.start.x + 3*Math.pow(1-t,2)*t*this.cp1.x + 3*(1-t)*Math.pow(t,2)*this.cp2.x + Math.pow(t,3)*this.end.x;
                        const cy = Math.pow(1-t,3)*this.start.y + 3*Math.pow(1-t,2)*t*this.cp1.y + 3*(1-t)*Math.pow(t,2)*this.cp2.y + Math.pow(t,3)*this.end.y;

                        // Calculate angle
                        const tx = (3*Math.pow(1-t,2)*(this.cp1.x-this.start.x)) + (6*(1-t)*t*(this.cp2.x-this.cp1.x)) + (3*t*t*(this.end.x-this.cp2.x));
                        const ty = (3*Math.pow(1-t,2)*(this.cp1.y-this.start.y)) + (6*(1-t)*t*(this.cp2.y-this.cp1.y)) + (3*t*t*(this.end.y-this.cp2.y));
                        const angle = Math.atan2(ty, tx);

                        const sideAngle = angle + (Math.random() > 0.5 ? 1.2 : -1.2); 
                        // Larger leaves here
                        this.leaves.push(new Leaf(cx, cy, sideAngle, config.leafSizeBase + Math.random() * 6));
                    }
                }
            }

            draw(ctx, time) {
                // Calculate "Breathing" movement
                // We move the control points slightly to make the vine flex
                const swayX = Math.sin(time * 2 + this.animOffset) * 2; 
                const swayY = Math.cos(time * 1.5 + this.animOffset) * 2;

                const d_cp1x = this.cp1.x + swayX;
                const d_cp1y = this.cp1.y + swayY;
                const d_cp2x = this.cp2.x - swayX; // Opposite sway for wave effect
                const d_cp2y = this.cp2.y + swayY;

                // Shadow
                ctx.beginPath();
                ctx.moveTo(this.start.x, this.start.y);
                ctx.bezierCurveTo(d_cp1x, d_cp1y, d_cp2x, d_cp2y, this.end.x, this.end.y);
                ctx.lineWidth = 3 + Math.sin(time*3)*0.4; // Thinner shadow (was 4)
                ctx.strokeStyle = 'rgba(0,0,0,0.6)';
                ctx.lineCap = 'round';
                ctx.stroke();

                // Stem
                ctx.lineWidth = 1.9; // Thinner stem (was 2.5)
                ctx.strokeStyle = config.colors.vineStem;
                ctx.stroke();

                // Highlight
                ctx.lineWidth = 0.75; // Thinner highlight (was 1)
                ctx.strokeStyle = 'rgba(152, 251, 152, 0.4)';
                ctx.stroke();

                // Leaves - Pass the approximate sway so they stick to the vine visually
                // (Approximation: using midpoint sway for all leaves on this segment)
                this.leaves.forEach(leaf => leaf.draw(ctx, time, swayX * 0.5, swayY * 0.5));
            }
        }

        class Letter {
            constructor(char, x, y, size) {
                this.char = char;
                this.x = x;
                this.y = y;
                this.size = size;
                this.vines = [];
                this.generateVines();
            }

            generateVines() {
                const w = this.size * 0.5; 
                const h = this.size * 0.7;
                const L = this.x - w/2;
                const R = this.x + w/2;
                const T = this.y - h/2;
                const B = this.y + h/2;
                const c = this.char.toUpperCase();

                // (Same heuristic logic as before, ensuring variety)
                if (['O', 'C', 'G', 'Q', 'U', 'D'].includes(c)) {
                    this.addSegment(L, B - h*0.3, L, T + h*0.3, true);   
                    this.addSegment(L, T + h*0.3, R, T, false);          
                    this.addSegment(R, T, R, B - h*0.3, true);           
                    this.addSegment(R, B - h*0.3, L, B, false);          
                } 
                else if (['S'].includes(c)) {
                    this.addSegment(R, T + h*0.2, L, T + h*0.2, true);
                    this.addSegment(L, T + h*0.2, R, B - h*0.2, false);
                    this.addSegment(R, B - h*0.2, L, B - h*0.2, true);
                }
                else if (['A', 'R', 'P', 'B'].includes(c)) {
                    this.addSegment(L, T + h*0.5, R, T + h*0.2, true);
                    this.addSegment(R, T + h*0.2, L, T, false);
                    this.addSegment(L, B, R, B - h*0.3, true);
                }
                else if (['N', 'M', 'W', 'K', 'X', 'V', 'Z'].includes(c)) {
                    this.addSegment(L, B, R, T, true);   
                    this.addSegment(R, T, R, B, false);  
                }
                else if (['L', 'I', 'T', 'H', 'E', 'F', 'J'].includes(c)) {
                    this.addSegment(L, B, R, B - h*0.3, true);
                    this.addSegment(R, B - h*0.3, L, B - h*0.6, false);
                    this.addSegment(L, B - h*0.6, R, T + h*0.2, true);
                }
                else {
                    this.addSegment(L, B, R, T, true);
                }
            }

            addSegment(x1, y1, x2, y2, isFront) {
                const mx = (x1 + x2) / 2;
                const cp1x = x1 + (mx - x1) * 0.5 + randomRange(-15, 15);
                const cp1y = y1 + (randomRange(-25, 25));
                const cp2x = x2 - (x2 - mx) * 0.5 + randomRange(-15, 15);
                const cp2y = y2 + (randomRange(-25, 25));
                this.vines.push(new VineSegment(x1, y1, x2, y2, cp1x, cp1y, cp2x, cp2y, isFront));
            }

            drawText(ctx) {
                ctx.font = `900 ${this.size}px 'Exo 2'`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.lineJoin = 'round';

                // 1. Shadow (Deepest Layer)
                ctx.lineWidth = this.size * 0.08; 
                ctx.strokeStyle = config.colors.bronzeShadow;
                ctx.strokeText(this.char, this.x + 2, this.y + 2); 

                // 2. Main Gold Outline
                ctx.lineWidth = this.size * 0.08;
                ctx.strokeStyle = config.colors.goldOutline;
                ctx.strokeText(this.char, this.x, this.y);

                // 3. Inner Rim (Highlight) - Drawn BEFORE fill so it doesn't overlap the black
                ctx.lineWidth = this.size * 0.03; 
                ctx.strokeStyle = '#ffe680';
                ctx.strokeText(this.char, this.x, this.y);

                // 4. Fill (Top Layer) - Overlays all stroke inner-halves
                ctx.fillStyle = config.colors.textFill;
                ctx.fillText(this.char, this.x, this.y);
            }

            drawVinesBack(ctx, time) { this.vines.filter(v => !v.isFront).forEach(v => v.draw(ctx, time)); }
            drawVinesFront(ctx, time) { this.vines.filter(v => v.isFront).forEach(v => v.draw(ctx, time)); }
        }

        let letters = [];
        
        function init() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            letters = [];
            
            // Responsive sizing
            const fontSize = Math.min(canvas.width / 10, 140);
            
            // --- LINE 1: SOLARPUNK ---
            const line1 = config.lines[0];
            ctx.font = `900 ${fontSize}px 'Exo 2'`;
            
            // Fixed Stride: Force equal distance between centers of letters
            // 0.85 is a good ratio for tight, blocky text
            const charStride1 = fontSize * 0.85; 
            const totalWidth1 = (line1.length - 1) * charStride1;
            
            const startX1 = (canvas.width - totalWidth1) / 2;
            const y1 = canvas.height / 2 - fontSize * 0.6;

            for(let i=0; i<line1.length; i++) {
                letters.push(new Letter(line1[i], startX1 + (i * charStride1), y1, fontSize));
            }

            // --- LINE 2: CORPS ---
            const line2 = config.lines[1];
            const fontSize2 = fontSize * 0.8;
            ctx.font = `900 ${fontSize2}px 'Exo 2'`;
            
            const charStride2 = fontSize2 * 0.85;
            const totalWidth2 = (line2.length - 1) * charStride2;
            
            const startX2 = (canvas.width - totalWidth2) / 2;
            const y2 = canvas.height / 2 + fontSize * 0.7;

            for(let i=0; i<line2.length; i++) {
                letters.push(new Letter(line2[i], startX2 + (i * charStride2), y2, fontSize2));
            }
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            config.animTime += 0.01; // Slower, delicate speed (was 0.03)

            const bgGrad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 50, canvas.width/2, canvas.height/2, canvas.width);
            bgGrad.addColorStop(0, '#111a14');
            bgGrad.addColorStop(1, '#020302');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0,0, canvas.width, canvas.height);

            letters.forEach(l => l.drawVinesBack(ctx, config.animTime));
            letters.forEach(l => l.drawText(ctx));
            letters.forEach(l => l.drawVinesFront(ctx, config.animTime));

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', init);
        document.fonts.ready.then(() => {
            init();
            animate();
        });

    </script>
</body>
</html>